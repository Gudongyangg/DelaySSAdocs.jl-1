var documenterSearchIndex = {"docs":
[{"location":"tutorials/bursty/#A-bursty-model-with-delay","page":"A bursty model with delay","title":"A bursty model with delay","text":"","category":"section"},{"location":"tutorials/bursty/#Model-definition","page":"A bursty model with delay","title":"Model definition","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"We study the following model which does not have an explicit gene state description and that the product (RNA or protein denoted as P) is actively transcribed in bursts whose size are distributed according to a geometric distribution. This means the propensity functions is is given by f(n) = ab^n(1+b)^n+1 for any positive integer n. Our bursty model writes:  The system has an explict solution which is obtained in [1, Supplementary Note Section 2]. We first construct reaction network","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"fracab^n(1+b)^n+1 emptyset rightarrow nP text triggers nPRightarrowemptyset text after tau time","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"The system has an explict solution which is obtained in [1, Supplementary Note Section 2]. We first construct reaction network","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"@parameters a b t\n@variables X(t)\nburst_sup = 30\nrxs = [Reaction(ab^n/(1+b)^{n+1},nothing,[X],nothing,[n]) for n in 1:burst_sup]\nrxs = vcat(rxs)\n@named rs = ReactionSystem(rxs,t,[X],[a,b])","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"In the example, we set a=00282 and b=346 and set the upper bound of bursting as burst_sup = 30. This means we ignore all the reactions ab^n(1+b)^n+1emptyset rightarrow nP for any n  30 where the reaction rate ab^n(1+b)^n+1 sim 10^-6.  We first convert the ReactionSystem to a JumpSystem and initialise the problem by setting","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"jumpsys = convert(JumpSystem, rs, combinatoric_ratelaws=false)\nu0 = [0]\nde_chan0 = [[]]\ntf = 200.\ntspan = (0,tf)\ntimestamp = 0:1:tf\nps = [0.0282, 3.46]\nτ = 130.","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"where de_chan0 is the initial condition for the delay channel where we assume no ongoing delay reactions at t=0. Next, we define delay trigger funtion append!(de_chan[1], fill(τ, i)) for iin 1ldots30.","category":"page"},{"location":"tutorials/bursty/#Defining-a-DelayJumpSet","page":"A bursty model with delay","title":"Defining a DelayJumpSet","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"delay_trigger_affect! = []\nfor n in 1:burst_sup\n    push!(delay_trigger_affect!, function (de_chan, rng)\n    append!(de_chan[1], fill(τ, n))\n    end)\nend\ndelay_trigger_affect!\ndelay_trigger = Dict([Pair(i, delay_trigger_affect![i]) for i in 1:burst_sup])\ndelay_complete = Dict(1=>[1=>-1])\ndelay_interrupt = Dict()\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"delay_trigger\nKeys: Indices of reactions defined in jumpset that can trigger the delay reaction. Here we have burst_sup = 30 reactions ab^n(1+b)^n+1emptyset rightarrow nP, that will trigger nP to degrade after time tau.\nValues: A update function that determines how to update the delay channel. In this example, once the delay reaction is trigged, the delay channel (which is the channel for P) will be added an array of delay time tau depending on the bursting number n.\ndelay_interrupt \nThere are no delay interrupt reactions in this example so we set delay_interrupt = Dict()\ndelay_complete \nKeys: Indices of delay channel. Here we only have one delay channel for P.\nValues: A vector of Pairs, mapping species id to net change of stoichiometric coefficient.","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"We define the delay SSA problem","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"dprob = DiscreteProblem(jumpsys,u0,tspan,ps)\njprob = DelayJumpProblem(jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0, save_positions=(false,false))","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"where DelayJumpProblem inputs DelayJumpProblem, DelayJumpSet and the initial condition of the delay channel de_chan0.","category":"page"},{"location":"tutorials/bursty/#Visualisation","page":"A bursty model with delay","title":"Visualisation","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"using DiffEqJump\nensprob = EnsembleProblem(jprob)\n@time ens = solve(ensprob, SSAStepper(), EnsembleThreads(), trajectories=10^5)","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"Then check with the exact probability distribution (Image: bursty)","category":"page"},{"location":"tutorials/bursty/#Reference","page":"A bursty model with delay","title":"Reference","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"[1] Qingchao Jiang#, Xiaoming Fu#, Shifu Yan#, Runlai Li, Wenli Du, Zhixing Cao*, Feng Qian, Ramon Grima*, \"Neural network aided approximation and parameter inference of non-Markovian models of gene expression\". Nature communications, (2021) 12(1), 1-12. https://doi.org/10.1038/s41467-021-22919-1","category":"page"},{"location":"algorithms/delayrejection/#Delay-Rejection-Method-Algorithm","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"","category":"section"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"  Simulation methods for systems with delays need to calculate when reactions initiate and store when they complete. However, because of the delayed reactions, the propensity functions can change between initiation times. Bratsun et al. [1] and Barrio et al. [2] used an algorithm for computing the initiation times that is exactly like the original Gillespie Algorithm except that if there is a stored delayed reaction set to finish within a computed timestep, then the computed timestep is discarded, and the system is updated to incorporate the stored delayed reaction. The algorithm then attempts another step starting at its new state. This algorithm is called Rejection Method.","category":"page"},{"location":"algorithms/delayrejection/#Algorithm","page":"Delay Rejection Method Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"Initialize. Set the initial number of molecules of each species and set t = 0.\nCalculate the propensity function, a_k, for each reaction.\nSet a_0 = sum_k=1^M a_k.\nGenerate an independent uniform (01) random number, r_1, and set Delta = 1a_0 ln(1r_1).\nIf there is a delayed reaction set to finish in t t + Delta)\nDiscard Delta.\nUpdatetto be the time of the next delayed reaction,mu.\nUpdatexaccording to the stored reaction mu.\nElse\nGenerate an independent uniform(01) random number r_2.\nFind muin1ldots m such that\nsum_k=1^mu-1 a_k(t)  r_2 a_0  sum_k=1^mu a_k(t)\nIf muin textND, update the number of each molecular species according to reaction mu.\nIf muin textCD, store the information that at time t+tau_mu the system must be updated according to reaction mu.\nIf muin textICD, update the system according to the initiation of mu and store that at time t+tau_mu the system must be updated according to the completion of reaction mu.\nSet t = t +Delta\nEndif\nReturn to step 2 or quit.","category":"page"},{"location":"algorithms/delayrejection/#Reference","page":"Delay Rejection Method Algorithm","title":"Reference","text":"","category":"section"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"[1] Dmitri A. Bratsun, Dmitri N. Volfson, Jeff Hasty, and Lev S. Tsimring \"Non-Markovian processes in gene regulation (Keynote Address)\", Proc. SPIE 5845, Noise in Complex Systems and Stochastic Dynamics III, (23 May 2005). https://doi.org/10.1117/12.609707","category":"page"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"[2]  Manuel Barrio, Kevin Burrage, André Leier, Tianhai Tian. \"Oscillatory Regulation of Hes1: Discrete Stochastic Delay Modelling and Simulation\", PLoS Computational Biology, 10.1371(2006). https://doi.org/10.1371/journal.pcbi.0020117","category":"page"},{"location":"algorithms/notations/#Notations-and-Basic-Concepts","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"","category":"section"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"  Consider a system consisting of N geq 1 chemical species, X_1ldots X_N, undergoing M geq 1 chemical reactions through reaction channels R_1ldotsR_M, each of which is equipped with a propensity function (or intensity function in the mathematics literature), a_k(X). The dynamic state of this chemical system can be described by the state vector X(t) =X_1(t)ldotsX_N(t)^T, where X_n(t)n = 1ldotsN, is the number of X_n molecules at time t, and ^T denotes the transpose of the vector in the bracket.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"  Delays, tau  0, in systems are between the initiation and completion of some, or all, of the reactions. And tau_k is used to represent the delay time of the k-th reaction in all delayed reactions, k = 0ldotsd. Notice that the definition of tau_k  is not the next reaction time Delta. We partition the reactions into three sets, those with no delays, denoted textND, those that change the state of the system only upon completion, denoted textCD, and those that change the state of the system at both initiation and completion, denoted textICD. The following assumption, sometimes called the fundamental premise of chemical kinetics, is based upon physical principles and serves as the base assumption for simulation methods of chemically reacting systems with delays:","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"beginaligned\na_k(X(t)) Delta t + omicron (t) =  text the probability that  reaction k \n text takes place in a small time interval t t + Delta t)\nendaligned","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"where omicron (Delta t)Delta t rightarrow 0  as  Delta t rightarrow 0.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"  Because the assumption above only pertains to the initiation times of reactions we must handle the completions separately. There are three different types of reactions, so there are three cases that need consideration.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Case 1: If reaction k is in textND and initiates at time t, then the system is updated by losing the reactant species and gaining the product species at the time of initiation.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Case 2: If reaction k is in textCD and initiates at time t, then the system is updated only at the time of completion, t + tau_k, by losing the reactant species and gaining the product species.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Case 3: If reaction k is in textICD and initiates at time t, then the system is updated by losing the reactant species at the time of initiation, t, and is updated by gaining the product species at the time of completion,t + tau_k.","category":"page"},{"location":"tutorials/delay_oscillator/#A-delay-induced-oscillator","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"Let us study the following delay oscillatory network.","category":"page"},{"location":"tutorials/delay_oscillator/#Model-definition","page":"A delay-induced oscillator","title":"Model definition","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"The model is defined as follows:","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"emptyset xrightarrowJ_1(Y) X\n YxrightarrowJ_2(Y) emptyset","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"and emptyset xrightarrowJ_1(Y) X will trigger XRightarrow Y after tau time.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"According to Neural network aided approximation and parameter inference of non-Markovian models of gene expression, it's an Illustration of a model of auto-regulation whereby a protein X is transcribed by a gene, then it is transformed after a delay time tau into a mature protein Y, which binds the promoter and represses transcription of X. The function J_1(Y) and J_2(Y) can be defined as follows:","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"J_1(Y)=k_1SfracK^p_dK^p_d+Y^pJ_2(Y)=k_2E_TfracYK_m+Y","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"In this example, we assume k_1=k_2=S=E_T=K_d=P=K_m=1 for convenience.","category":"page"},{"location":"tutorials/delay_oscillator/#Define-a-JumpSet","page":"A delay-induced oscillator","title":"Define a JumpSet","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"Since the rate varies with the number of molecules of Y, we should define ConstantRateJump","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"rate1 = (u,p,t) -> 1/(1+u[2]^2)\naffect1! = function (integrator)\nintegrator.u[1] += 1\nend\ncons_jump1 = ConstantRateJump(rate1,affect1!)\n\nrate2 = (u,p,t) -> u[2]/(1+u[2])\naffect2! = function (integrator)\nintegrator.u[2] -= 1\nend\ncons_jump2 = ConstantRateJump(rate2,affect2!)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"rates A function showing how the rate varies with the change of molecules of Y.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"affect! is a function that shows the net change in the species when the reaction occurs.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"Then we can define the JumpSet","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"jumpset = JumpSet((),(cons_jump1,cons_jump2),nothing,nothing)","category":"page"},{"location":"tutorials/delay_oscillator/#Define-a-DiscreteProblem","page":"A delay-induced oscillator","title":"Define a DiscreteProblem","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"Then we initialise the problem by setting","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"u0 = [0,0]\nde_chan0 = [[]]\ntf = 400.\ntspan = (0,tf)\nτ = 20.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"So we can define the DiscreteProblem","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"dprob = DiscreteProblem(u0, tspan)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"The same as we did before, we must define the DelayJumpSet","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"delay_trigger_affect! = function (de_chan, rng)\n    append!(de_chan[1], τ)\nend\ndelay_trigger = Dict(1=>delay_trigger_affect!)\ndelay_complete = Dict(1=>[2=>1, 1=>-1])\ndelay_interrupt = Dict()\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"We can see how to define the  DelayJumpSet in this example.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"So we can define the DelayJumpProblem","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"djprob = DelayJumpProblem(dprob, DelayRejection(), jumpset, delayjumpset, de_chan0, save_positions=(true,true))","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"where DelayJumpProblem inputs DiscreteProblem, JumpSet,DelayJumpSet, the algorithm we choose and the initial condition of the delay channel de_chan0.","category":"page"},{"location":"tutorials/delay_oscillator/#Solution-and-Visualisation","page":"A delay-induced oscillator","title":"Solution and Visualisation","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"Now we can solve the problem and plot two trajectories of X and Y.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"sol_1 = solve(djprob, SSAStepper())\nsol_2 = solve(djprob, SSAStepper())","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"(Image: oscillator1)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"(Image: oscillator2)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"Then we simulate 10^4 trajectories and calculate the evolution of mean value for each reactant.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"using StatsBase\nSample_size = Int(1e4)\nens_prob = EnsembleProblem(djprob)\nens = solve(ens_prob,SSAStepper(),EnsembleThreads(),trajectories = Sample_size, saveat = .1, save_delay_channel =false)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"(Image: oscillator3)","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"If we want to see how Y varies accoring to the number of X, we will find the following oscillary orbit in the phase diagram.","category":"page"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"(Image: oscillator4)","category":"page"},{"location":"tutorials/delay_oscillator/#Reference","page":"A delay-induced oscillator","title":"Reference","text":"","category":"section"},{"location":"tutorials/delay_oscillator/","page":"A delay-induced oscillator","title":"A delay-induced oscillator","text":"[1] Qingchao Jiang#, Xiaoming Fu#, Shifu Yan#, Runlai Li, Wenli Du, Zhixing Cao, Feng Qian, Ramon Grima, \"Neural network aided approximation and parameter inference of non-Markovian models of gene expression\". Nature communications, (2021) 12(1), 1-12. https://doi.org/10.1038/s41467-021-22919-1","category":"page"},{"location":"api/#Main-API","page":"API","title":"Main API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [DelaySSAToolkit]","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#Exact-Stochastic-Simulation-Algorithm-(SSA)-Without-Delays","page":"Theory","title":"Exact Stochastic Simulation Algorithm (SSA) Without Delays","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Consider a system consisting of N geq 1 chemical species, X_1ldots X_N, undergoing M geq 1 chemical reactions through reaction channels R_1ldotsR_M, each of which is equipped with a propensity function (or intensity function in the mathematics literature), a_k(X). The dynamic state of this chemical system can be described by the state vector X(t) =X_1(t)ldotsX_N(t)^T, where X_n(t)n = 1ldotsN is the number of X_n molecules at time t, and ^T denotes the transpose of the vector in the bracket.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Following Gillespie [1], the dynamics of reaction R_k defined by a state-change vector nu_k = nu_1k ldotsnu_Nk^T, where nu_nk gives the changes in the X_n molecular population produced by one R_k reaction, and a propensity function a_k(t) together with the fundamental premise of stochastic chemical kinetics:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\na_k(t)Delta t = text the probability given  X(t)=mathbfx \ntext that one reaction R_k text will occur in the\ntext next infinitesimal time interval tt+Delta t\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Defining the probability rate constant c_k as the probability that a randomly selected combination of R_k reactant molecules reacts in a unit time period, we can calculate  a_k(t) from c_k and the molecular numbers of R_k reactants at time t using the method given by Gillespie.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  For a chemical system in a given state X(t)=mathbfx at time t, assuming that all reactions occur instantly, Gillespie’s exact SSA answers the following two questions: (i)  when will the next reaction occur?  (ii)  which reaction will occur? Specifically, Gillespie’s exact SSA simulates the following event in each step:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\ntextE   textno reaction occurs in the time interval tt+Delta\n textand a reaction R_mu  textoccurs in the infinitesimal\n texttime interval t+Deltat+Delta+Delta t\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Based upon the fundamental premise Eq. (1), Gillespie showed that that Delta and mu are two independent random variables and have the following probability density functions (textPDFs), respectively:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nf_Delta(Delta)=a_0(t) exp(-a_0(t)Delta)     Delta  0\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nf_mu(mu)=a_mu(t) over a_0(t)      mu = 1ldotsM\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where a_0(t)=beginmatrix sum_k=1^M a_k(t) endmatrix. According to the textPDF Eq. (4), a realization of mu can be generated from a standard uniform random variable r_2, by taking mu to be the integer for which sum_k=1^mu-1 a_k(t)   r_2 a_0(t) leq sum_k=1^mu a_k(t);based on the textPDF Eq. (3), a realization of Delta can be generated from another standard uniform random variable r_1 as Delta=ln(r_1)a_0(t). Therefore, Gillespie’s exact SSA generates a realization of mu and Delta in each step of simulation, and then updates the time and system state as tleftarrow t+Delta and  mathbfx leftarrow mathbfx+ mathbfnu_mu, respectively.","category":"page"},{"location":"theory/#Exact-SSA-For-Coupled-Chemical-Reaction-With-Delays","page":"Theory","title":"Exact SSA For Coupled Chemical Reaction With Delays","text":"","category":"section"},{"location":"theory/#Delay-Direct-method","page":"Theory","title":"Delay Direct method","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"  As in the derivation of Gillespie’s exact SSA, we first need to find the probability of event Eq. (2), that is defined as P(Deltamu)dDelta, where P(Deltamu) is the joint PDF of Delta and mu. Suppose that there are d ongoing reactions at time t, which will finish at t+T_1ldotst+T_d, respectively. Without loss of generality, we assume that T_1 leq T_2 leq ldots leq T_d. Unlike in the reaction system without delays where the propensity functions remain unchanged in the time interval tt+Delta, the propensity functions here change at t+T_ii=1ldotsd, due to delayed reactions. We need to take into account such changes in propensity functions when deriving  P(Deltamu).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  As in the derivation of Gillespie’s exact SSA, P(Deltamu)dDelta can be found from the fundamental premise Eq. (1) as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nP(Deltamu)dDelta=P_0(Delta) a_mu(t +Delta)dDelta\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where P_0(Delta) is the probability that no reaction will occur in the time interval tt+Delta, while a_mu(t+Delta)dDelta is the probability that a reaction R_mu occurs in t+Deltat+Delta+dDelta. Defining T_0=0 and T_d+1=infty, we can find P_0(Delta) for Delta that lies in different time intervals T_iT_i+1)i=0ldotsd. If Delta in T_iT_i+1), we define the event E_k as the event that no reaction occurs in the time interval t+T_kt+T_k+1)k=0ldotsk=i1, respectively,and the event  E_i  as the event that no reaction occurs in the time interval t+T_it+Delta). Then, we can express P_0(Delta) as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nP_0(Delta)=P(E_0ldotsE_i)=P(E_0) prod_k=1^i P(E_k丨E_0ldotsE_k-1)\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"From the derivation of Gillespie’s exact SSA,we know that  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"P(E_0) = exp (a_0(t)T_1)\nP_0(E_k丨E_0ldotsE_k-1) = exp(-a_0(t+T_k))  (T_k+1T_k)k=0ldotsi1\nP(E_i丨E_0ldotsE_i-1) = exp(-a_0(t+T_i)(Delta-T_i))","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that propensity functions change at t+T_k after a delayed reaction finishes, and we use a_0(t+T_k) to represent the new a_0. The probability P_0(Delta) is then given by","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\n P_0(Delta) = exp bigg (-sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k)-a_0(t+T_i)(Delta-T_i) bigg ) \n Delta in T_iT_i+1) i = 0ldotsd\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we assume that the first term of the exponent is equal to zero when i = 0. Since P_0(Delta) does not depend on individual propensity functions, as shown in Eq. (7), it is seen from Eq. (5) that Delta and mu are independent random variables. Combining Eq. (5) and Eq. (7) and noticing that a_mu(t+Delta)=a_mu(t+T_i) for Delta in T_iT_i+1), we obtain the textPDF of Delta and mu as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\n f_Delta(Delta) = a_0(t+T_i) exp bigg (-sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k) - a_0(t+T_i)(Delta-T_i) bigg ) \n Delta in T_iT_i+1) i = 0ldotsd\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"f_mu(mu)= a_mu(t+T_i) over a_0(t+T_i)     mu = 1ldotsM    Delta in T_iT_i+1)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"It is not difficult to verify that int_0^infty f_Delta(Delta) dDelta = 1. In simulation, mu can be generated, from a standard uniform random variable u_1, by taking mu to be the integer for which beginmatrix sum_k=1^mu-1 a_k(t+T_i) endmatrix  u_1 a_0(t+T_i)  beginmatrix sum_k=1^mu a_k(t+T_i) endmatrix, after Delta is generated to be in the time interval T_iT_i+1).We next derive the method of generating  Delta according to its textPDF in Eq. (8).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  The cumulative distribution function of Deltacan be found from Eq. (8) as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n F_Delta(Delta)=1 - exp  bigg (-sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k)-a_0(t+T_i)(Delta-T_i) bigg ) \n Delta in T_iT_i+1) i = 0ldotsd\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, we can generate Delta from a standard uniform random variable u_2, by taking Delta=F_Delta^1(u_2), where F_Delta^1(cdot) represents the inverse of F_Delta(Delta). More specifically, we can obtain Delta as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Find T_i such that  F_Delta(T_i)  u_2  F_Delta(T_i+1), then calculate  Delta from","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n Delta = T_i + -ln (1-u_2)-beginmatrix sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k) endmatrix  over a_0(t+T_i) \n Delta in T_iT_i+1)\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Since we need T_1ldotsT_d to generate Delta and mu, we define an array of data structures, named Tstruct, whose ith (i=1ldotsd) cell stores T_i and the index, mu_i, of the reaction that T_i is associated with. The reaction index mu_i is needed during the generation of Delta, when we update the propensity functions affected by the reaction that is delayed but finishes at t+T_i. During simulation, we need to generate Delta and mu, maintain Tstruct, and then update the state vector X(t).","category":"page"},{"location":"theory/#Delay-Rejection-method","page":"Theory","title":"Delay Rejection method","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Now let us see whether the rejection method can correctly simulate the event (2). The rejection algorithm essentially generates Delta in the event (2) using a rejection method in an iterative fashion: in the i-th iteration, it generates a Delta_i iaccording to an exponential textPDF with parameter a_0(t+T_i1), where we have denoted the Delta generated in the i-th iteration as Delta_i. If Delta_i  T_i - T_i1, then we have Delta = sum_k=0^i-1 T_k+Delta_i and the algorithm continues simulation to generate mu; otherwise, it rejects Delta_i, updates the state vector X(t+T_i), calculates a_k(t+T_i)k=1ldotsM, and goes to the next iteration. If Delta is determined in the (i+1)-th iteration, where i is a non-negative integer, then we have Delta in T_iT_i+1) and i delayed reactions finished in the time interval tt+Delta). ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  From the iterative procedure of generating Delta described above, we can find P_0(Delta) that the rejection method algorithm produces. Specifically, if Delta in T_iT_i+1), we have P(E_0)=P(Delta_1  T_1), P(E_k丨E_0ldotsE_k-1) = P(Delta_k+1  T_k+1 - T_k) k=1ldotsi1, because Delta_kk=1ldotsi, are rejected. Since Delta_k+1 is accepted, at least one reaction will occur in the time interval t+T_it+Delta), if Delta_i+1  Delta T_i. Thus, P(E_i丨E_0ldotsE_i-1) = 1P(Delta_i+1  Delta - T_i) = P(Delta_i+1  Delta - T_i). Therefore, for the rejection method, P_0(Delta) in Eq. (6) can be written as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nP_0(Delta) = P(Delta_i+1  Delta - T_i) prod_k=1^i P(Delta_k  T_k - T_k-1)\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  The random variables  Delta_kk=1ldotsi+1, follow an exponential distribution with parameter a_0(t+T_k1), and thus we have","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\n P(Delta_k  T_k - T_k-1) = exp(-a_0(t+T_k-1)(T_k - T_k-1)) \n k= 1ldotsi\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nP(Delta_i+1  Delta T_i) = exp(-a_0(t+T_i)(Delta-T_i))\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Substituting Eqs. (10) and (11) into Eq. (9), we find that P_0(Delta) in Eq. (9) is exactly the same as P_0(Delta) in Eq. (7) that is derived directly from the event (2) and the fundamental premise (1). Since our algorithm generates Delta and mu according to textPDFs of Delta and mu derived from P_0(Delta) in Eq. (7), the rejection method is equivalent to our direct method and also is an exact SSA for chemical reaction systems with delays.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  We next analyze the complexity of the rejection method algorithm and the direct method algorithm. As we have seen, the difference between two algorithms lies in the generation of Delta. Suppose that both algorithms generate a  Delta in T_iT_i+1), where i is a non-negative integer. Both algorithms update the state vector x at t+T_k, k=1ldotsi, and calculate a_k(t+T_k) and a_0(t+T_k), k=1ldotsi. The direct method algorithm also calculates a_k(t+T_i+1) and a_0(t+T_i+1), but a_k(t+T_i+1) and a_0(t+T_i+1) can be reused in generating next Delta. Therefore, two algorithms require the same computation on calculating propensity functions and updating the state vector. The direct method algorithm needs to evaluate the exponential function and calculateat a_t i+1  times, while the rejection method does not need such operations. Also, the direct method needs slightly more computation on calculating Delta from a uniform random variable than the rejection method algorithm. To generate a Delta, the direct method algorithm generates exactly one uniform random variable regardless of the value of i, while the rejection method algorithm generates i+1 uniform random variable. ","category":"page"},{"location":"theory/#Reference","page":"Theory","title":"Reference","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"[1] Daniel T. Gillespie, \"Exact stochastic simulation of coupled chemical reactions\", The Journal of Physical Chemistry 1977 81 (25), 2340-2361. https://doi.org/10.1021/j100540a008.","category":"page"},{"location":"tutorials/tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"This tutorial is aims to explain how to use DelaySSAToolkit to define chemical reaction models, solve the problem and visualize the results. To demonstrate the functionalities, we will consider a specific case from epideimc modelling as follows","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"S+IxrightarrowrhoE+I\nIstackrelrrightarrowR","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"and S+Ixrightarrowrho E+I will trigger ERightarrow I after tau time, where S, I and R are the susceptible, infected and removed populations. E represents the exposed population. It means, wtih rate rho, a susceptible contacted by an infected will become an individual that is exposed to the disease and then it takes certain amount of time delay tau to become an infected inidividual.","category":"page"},{"location":"tutorials/tutorials/#Model","page":"Tutorials","title":"Model","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Catalyst.jl provides a comprehensive interface to modelling reaction networks in Julia and can be used to construct models fully-compatible with DelaySSAToolkit. For more details on how to construct a reaction network, we recommend reading Catalyst's tutorial. In our example, the model can be defined as:","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"rn = @reaction_network begin\n    ρ, S+I --> E+I\n    r, I --> R\nend ρ r","category":"page"},{"location":"tutorials/tutorials/#Define-DelayJumpProblem","page":"Tutorials","title":"Define DelayJumpProblem","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"What differs from the Markov process that can be modelled via SSA is the introduction of delay reactions. To show how we incorporate the delay reactions into the Markovian system, we first need to define what we called DelayJumpProblem. Here we show two routes to define our DelayJumpProblem, one way is based on JumpSystem, DiscreteProblem and DelayJumpSet, the other is based on JumpSet, DiscreteProblem and DelayJumpSet.","category":"page"},{"location":"tutorials/tutorials/#First-route:-JumpSystem-DiscreteProblem-DelayJumpSet","page":"Tutorials","title":"First route: JumpSystem + DiscreteProblem + DelayJumpSet","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We can easily obtain Jumpsystem from the reaction network rn that is previously defined using Catalys interface.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"jumpsys = convert(JumpSystem, rn, combinatoric_ratelaws=false)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"where combinatoric_ratelaws is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie, and hence need to be rescaled. The default, scale_rates=true, corresponds to rescaling the passed in rate constants. When using MassActionJump the default behavior is to assume rate constants correspond to stochastic rate constants in the sense used by Gillespie [1]. This means that for a reaction such as 2A oversetkrightarrow B, the jump rate function constructed by MassActionJump would be k*A*(A-1)/2!. For a trimolecular reaction like 3A oversetkrightarrow B the rate function would be k*A*(A-1)*(A-2)/3!. To avoid having the reaction rates rescaled (by 1/2 and 1/6 for these two examples), one can pass the JumpSystem constructor the optional named parameter combinatoric_ratelaws=false see Reaction rate laws used in simulations for details.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"With the initial conditions, we can then define DiscreteProblem","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"u0 = [999,1,0,0]\nde_chan0 = [[]]\ntf = 400.\ntspan = (0,tf)\nps = [1e-4, 1e-2] # parameters for ρ, r\nτ = 20.\ndprob = DiscreteProblem(jumpsys,u0,tspan,ps)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"where DiscreteProblem inputs jumpsys, and the initial condition of reactants u0 , the simulation timespan tspan and the reaction rates ps.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Here the delay reation comes in, we define the DelayJumpSet by","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"delay_trigger_affect! = function (integrator, rng)\n    append!(integrator.de_chan[1], τ)\nend\ndelay_trigger = Dict(1=>delay_trigger_affect!)\ndelay_complete = Dict(1=>[2=>1, 3=>-1])\ndelay_interrupt = Dict()\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"delay_trigger::Dict  A dictionary that contains\nKeys: Indices of reactions defined in JumpSystem that can trigger the delay reaction see indices in the JumpSystem. Here we have the first reaction S+IRightarrow E+ I that will trigger the transfer from E to I after time tau, thus the key here is 1.\nValues: A update function that determines how to update the delay channel. In this example, once the delay reaction is trigged, the first delay channel will be added a delay time tau.\ndelay_interrupt::Dict\nThere are no delay interrupt reactions in this example so we set delay_interrupt = Dict().\ndelay_complete::Dict \nKeys: Indices of delay channels.\nValues: A vector of Pairs, mapping species index to net change of stoichiometric coefficient.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We can see more details in Defining a DelayJumpSet(bursty) and Defining a DelayJumpSet(birth-death example).","category":"page"},{"location":"tutorials/tutorials/#indice_notice","page":"Tutorials","title":"Remark on Reaction Indices","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"!!! warning JumpSystem will change the order of the reactions that is arranged in your reaction network. Internally, all MassActionJumps are ordered before ConstantRateJumps (with the latter internally ordered in the same order they were passed in). The same principle applies for the construction of JumpSet.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"At last, we can define the DelayJumpProblem by ","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"jprob = DelayJumpProblem(jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0, save_positions=(true,true))","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"where DelayJumpProblem inputs jumpsys,DiscreteProblem, DelayJumpSet, the algorithm we choose and the initial condition of the delay channel de_chan0.","category":"page"},{"location":"tutorials/tutorials/#Second-route:-JumpSet-DiscreteProblem-DelayJumpSet","page":"Tutorials","title":"Second route: JumpSet + DiscreteProblem + DelayJumpSet","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Here we explain how to define the DelayJumpProblem in another way. To that aim, we should first define the parameters and the mass-action jump (see Defining a Mass Action Jump for details) and construct Jumpset.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"ρ, r = [1e-4, 1e-2]\nrate1 = [ρ, r]\nreactant_stoich = [[1=>1,2=>1],[2=>1]]\nnet_stoich = [[1=>-1,3=>1],[2=>-1,4=>1]]\nmass_jump = MassActionJump(rate1, reactant_stoich, net_stoich; scale_rates =false)\njumpset = JumpSet((),(),nothing,mass_jump)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The JumpSet consists of four inputs, namely variable jumps, constant rate jumps, regular jumps and mass-action jumps. As far as discrete stochastic simulation is concerned, we only focus on constant rate jumps and mass-action jumps which is the second and fourth inputs of JumpSet (see different jump types for more details). Here we only have two mass-action jumps that are wrapped in mass_jump.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Then we initialise the problem by setting","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"u0 = [999,1,0,0]\nde_chan0 = [[]]\ntf = 400.\ntspan = (0,tf)\nτ = 20.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"As before, we can define the DiscreteProblem","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"dprob = DiscreteProblem(u0, tspan)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"and in the same way, we can define the  DelayJumpSet","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"delay_trigger_affect! = function (de_chan, rng)\n    append!(de_chan[1], τ)\nend\ndelay_trigger = Dict(1=>delay_trigger_affect!)\ndelay_complete = Dict(1=>[2=>1, 3=>-1])\ndelay_interrupt = Dict()\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Now we can define the problem","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"djprob = DelayJumpProblem(dprob, DelayRejection(), jumpset, delayjumpset, de_chan0, save_positions=(true,true))","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"where DelayJumpProblem inputs DiscreteProblem, JumpSet, DelayJumpSet, the algorithm we choose and the initial condition of the delay channel de_chan0.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"At last, we can solve the problem and visualize it","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"sol = solve(djprob, SSAStepper())","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"(Image: seir)","category":"page"},{"location":"tutorials/delay_multidegradation/#A-multi-next-delay-example","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"","category":"section"},{"location":"tutorials/delay_multidegradation/#Model-definition","page":"A multi-next-delay example","title":"Model definition","text":"","category":"section"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"The model is defined as follows: 1. Cemptyset rightarrow X_A; 2. gamma  X_A rightarrow emptyset   3 beta  X_A rightarrow  X_I1+X_I2, which triggers X_I1X_I2Rightarrow emptyset after tau time; 4. gamma  X_I1 rightarrow emptyset; 5. gamma  X_I2 rightarrow emptyset. The 4th and 5th reactions will cause the delay channel to change its state during a schduled delay reaction. Note this example is to test multiple delay reactions. The exact solution can be found in this example.","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"We first define the parameters and the mass-action jump (see Defining a Mass Action Jump for details).","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"C, γ, β, τ = [2., 0.1, 0.5, 15.]\nrate1 = [C,γ,β,γ,γ]\nreactant_stoch = [[],[1=>1],[1=>1],[2=>1],[3=>1]]\nnet_stoch = [[1=>1],[1=>-1],[1=>-1,2=>1,3=>1],[2=>-1],[3=>-1]]\nmass_jump = MassActionJump(rate1, reactant_stoch, net_stoch; scale_rates =false)\njumpsets = JumpSet((),(),nothing,[mass_jump])","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"We can see the definition of the parameters in this example.","category":"page"},{"location":"tutorials/delay_multidegradation/#Defining-a-DelayJumpSet","page":"A multi-next-delay example","title":"Defining a DelayJumpSet","text":"","category":"section"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"Then we turn to the definition of delay reactions","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"delay_trigger_affect! = function (de_chan, rng)\n   append!(de_chan[1], τ)\n   append!(de_chan[2], τ)\nend\ndelay_trigger = Dict(3=>delay_trigger_affect!)\ndelay_complete = Dict(1=>[2=>-1],2=>[3=>-1]) \n\ndelay_affect1! = function (de_chan, rng)\n    i = rand(rng, 1:length(de_chan[1]))\n    deleteat!(de_chan[1],i)\nend\ndelay_affect2! = function (de_chan, rng)\n    i = rand(rng, 1:length(de_chan[2]))\n    deleteat!(de_chan[2],i)\nend\ndelay_interrupt = Dict(4=>delay_affect1!,5=>delay_affect2!) \ndelaysets = DelayJumpSet(delay_trigger,delay_complete,delay_interrupt)","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"delay_trigger  \nKeys: Indices of reactions defined in jumpset that can trigger the delay reaction. Here we have the 3rd reaction beta  X_A rightarrow  X_I1+X_I2 that will trigger the X_I1 and X_I2 to degrade after time tau.\nValues: A update function that determines how to update the delay channel. In this example, once the delay reaction is trigged, the delay channel 1 (which is the channel for X_I1) and the delay channel 2 (which is the channel for X_I2 ) will be added a delay time tau.\t\t\t\t\t\ndelay_interrupt\nKeys: Indices of reactions defined in jumpset that can cause the change in delay channel. In this example, the 4th reaction gamma  X_I1 rightarrow emptyset and the 5th reaction gamma  X_I2 rightarrow emptyset will change the schduled delay reaction to change its state immediately.\nValues: A update function that determines how to update the delay channel. In this example, once a delay-interrupt reaction happens, any of the reactants X_I1 and X_I2 that are supposed to leave the system after time tau can be degraded immediately.\ndelay_complete: \nKeys: Indices of delay channel. Here the 1st delay channel corresponds to X_I1 and the 2 nd delay channel corresponds to X_I2 .\nValues: A vector of Pairs, mapping species id to net change of stoichiometric coefficient.","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"Now we can initialise the problem by setting","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"u0 = [0,0,0]\ntf = 30.\nsaveat = .1\nde_chan0 = [[],[]]\np = 0.\ntspan = (0.,tf)","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"where de_chan0 is the initial condition for the delay channel, which is a vector of arrays whose kth entry stores the schduled delay time for kth delay channel. Here we assume X_I1(0)X_I2(0)=0, thus only two empty arrays. Next, we choose a delay SSA algorithm DelayDirect() and define the problem","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"aggregatoralgo = DelayDirect()\nsave_positions = (false,false)\ndprob = DiscreteProblem(u0, tspan, p)\njprob = JumpProblem(dprob, aggregatoralgo, jumpsets, save_positions = (false,false))\ndjprob = DelayJumpProblem(jprob,delaysets,de_chan0)","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"where DelayJumpProblem inputs JumpProblem, DelayJumpSet and the initial condition of the delay channel de_chan0.","category":"page"},{"location":"tutorials/delay_multidegradation/#Visualisation","page":"A multi-next-delay example","title":"Visualisation","text":"","category":"section"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"Now we can solve the problem and plot a trajectory","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"sol =@time solve(djprob, SSAStepper(),seed=10, saveat =.1, save_delay_channel = false)","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"(Image: multidegradation1)","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"Then we simulate 10^4 trajectories and calculate the evolution of mean value for each reactant","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"using StatsBase\nSample_size = Int(1e4)\nens_prob = EnsembleProblem(djprob)\nens =@time solve(ens_prob,SSAStepper(),EnsembleThreads(),trajectories = Sample_size, saveat = .1, save_delay_channel =false)","category":"page"},{"location":"tutorials/delay_multidegradation/#Verification-with-the-exact-solution","page":"A multi-next-delay example","title":"Verification with the exact solution","text":"","category":"section"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"Lastly, we can compare with the mean values of the exact solutions X_IX_A (Image: multidegradation2) (Image: multidegradation3)","category":"page"},{"location":"tutorials/delay_degradation/#A-birth-death-example-with-delay-degradation","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"","category":"section"},{"location":"tutorials/delay_degradation/#Model-definition","page":"A birth-death example with delay degradation","title":"Model definition","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"The model is defined as follows: 1. Cemptyset rightarrow X_A; 2. gamma  X_A rightarrow emptyset; 3. beta  X_A rightarrow  X_I, which triggers X_IRightarrow emptyset after tau time; 4. gamma X_I rightarrow emptyset, which causes the delay channel to change its state during a schduled delay reaction.","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"This example is studied by Lafuerza and Toral in [1], where one can solve the solution analytically. If we denote langle X_Arangle(t) to be the mean value of X_A at time t, and langle X_Irangle(t) the mean value of X_I at time t, then","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"langle X_Arangle(t)= fracCa( 1-e^-at )quad langle X_Irangle(t) = begincases\nfracCbetaa-γbigfrac1-e^-γtγ-frac1-e^-atabig t in 0tau\nfracCbetaaBigfrac1-e^-γτγ+frac(1-e^tau(a-γ))a-γe^-atBig  t in (tauinfty)\nendcases","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"where a = β + γ.","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"We first define the parameters and the mass-action jump (see Defining a Mass Action Jump for details)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"C, γ, β, τ = [2., 0.1, 0.5, 15.]\nrate1 = [C,γ,β,γ]\nreactant_stoich = [[],[1=>1],[1=>1],[2=>1]]\nnet_stoich = [[1=>1],[1=>-1],[1=>-1,2=>1],[2=>-1]]\nmass_jump = MassActionJump(rate1, reactant_stoich, net_stoich; scale_rates =false)\njumpset = JumpSet((),(),nothing,[mass_jump])","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"rates  A vector of rates of reactions.\nreactant_stoch is a vector whose kth entry is the reactant stoichiometry of the kth reaction. The reactant stoichiometry for an individual reaction is assumed to be represented as a vector of Pairs, mapping species id to stoichiometric coefficient.\nnet_stoch  is assumed to have the same type as reactant_stoich; a vector whose kth entry is the net stoichiometry of the kth reaction. The net stoichiometry for an individual reaction is again represented as a vector of Pairs, mapping species id to the net change in the species when the reaction occurs.\nscale_rates is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie, and hence need to be rescaled. The default, scale_rates=true, corresponds to rescaling the passed in rate constants. When using MassActionJump the default behavior is to assume rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)). This means that for a reaction such as 2A oversetkrightarrow B, the jump rate function constructed by MassActionJump would be k*A*(A-1)/2!. For a trimolecular reaction like 3A oversetkrightarrow B the rate function would be k*A*(A-1)*(A-2)/3!. To avoid having the reaction rates rescaled (by 1/2 and 1/6 for these two examples), one can pass the MassActionJump constructor the optional named parameter scale_rates=false\nmass_jump  Define mass-action jumps\njumpsets  Wrap up the reactions into one jumpset.","category":"page"},{"location":"tutorials/delay_degradation/#Defining-a-DelayJumpSet","page":"A birth-death example with delay degradation","title":"Defining a DelayJumpSet","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Then we turn to the definition of delay reactions","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"delay_trigger_affect! = function (de_chan, rng)\n   append!(de_chan[1], τ)\nend\ndelay_trigger = Dict(3=>delay_trigger_affect!)\ndelay_complete = Dict(1=>[2=>-1]) \n\ndelay_affect! = function (de_chan, rng)\n    i = rand(rng, 1:length(de_chan[1]))\n    deleteat!(de_chan[1],i)\nend\ndelay_interrupt = Dict(4=>delay_affect!) \ndelaysets = DelayJumpSet(delay_trigger,delay_complete,delay_interrupt)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"delay_trigger  \nKeys: Indices of reactions defined in jumpset that can trigger the delay reaction. Here we have the 3rd reaction beta X_A rightarrow X_I that will trigger the X_I to degrade after time tau.\nValues: A update function that determines how to update the delay channel. In this example, once the delay reaction is trigged, the delay channel 1 (which is the channel for X_I) will be added a delay time tau.\t\t\t\ndelay_interrupt\nKeys: Indices of reactions defined in jumpset that can cause the change in delay channel. In this example, the 4th reaction gamma  X_I rightarrow emptyset will change the schduled delay reaction to change its state immediately.\nValues: A update function that determines how to update the delay channel. In this example, once a delay-interrupt reaction happens, any of the reactants X_I that is supposed to leave the system after time tau can be degraded immediately.  \ndelay_complete \nKeys: Indices of delay channel. Here the 1st delay channel corresponds to X_I.\nValues: A vector of Pairs, mapping species id to net change of stoichiometric coefficient.","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Now we can initialise the problem by setting ","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"u0 = [0, 0]\ntf = 30.\nsaveat = .1\nde_chan0 = [[]]\np = 0.\ntspan = (0.,tf)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"where de_chan0 is the initial condition for the delay channel, which is a vector of arrays whose kth entry stores the schduled delay time for kth delay channel. Here we assume X_I(0) = 0, thus only an empty array. Next, we choose a delay SSA algorithm DelayDirect() and define the problem","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"aggregatoralgo = DelayDirect()\nsave_positions = (false,false)\ndprob = DiscreteProblem(u0, tspan, p)\njprob = JumpProblem(dprob, aggregatoralgo, jumpset, save_positions = (false,false))\ndjprob = DelayJumpProblem(jprob,delaysets,de_chan0)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"where DelayJumpProblem inputs JumpProblem, DelayJumpSet and the initial condition of the delay channel de_chan0.","category":"page"},{"location":"tutorials/delay_degradation/#Visualisation","page":"A birth-death example with delay degradation","title":"Visualisation","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Now we can solve the problem and plot a trajectory","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"sol = solve(djprob, SSAStepper(), seed=2, saveat =.1, save_delay_channel = false)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Then we simulate 10^4 trajectories and calculate the evolution of mean value for each reactant","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"using DiffEqBase\nSample_size = Int(1e4)\nens_prob = EnsembleProblem(djprob)\nens =@time solve(ens_prob,SSAStepper(),EnsembleThreads(),trajectories = Sample_size, saveat = .1, save_delay_channel =false)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"(Image: degradation1)","category":"page"},{"location":"tutorials/delay_degradation/#Verification-with-the-exact-solution","page":"A birth-death example with delay degradation","title":"Verification with the exact solution","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Lastkt, we can compare with the mean values of the exact solutions X_I X_A","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"timestamps = 0:0.1:tf\na = β + γ \nmean_x_A(t) = C/a*(1-exp(-a*t))\nmean_x_I(t)= 0<=t<=τ ? C*β/(a-γ)*((1-exp(-γ*t))/γ - (1-exp(-a*t))/a) : C*β/a*((1-exp(-γ*τ))/γ + exp(-a*t)*(1-exp((a-γ)τ))/(a-γ))","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"(Image: degradation2) (Image: degradation3)","category":"page"},{"location":"tutorials/delay_degradation/#Reference","page":"A birth-death example with delay degradation","title":"Reference","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"[1] Lafuerza, L. F., & Toral, R. (2011). Exact solution of a stochastic protein dynamics model with delayed degradation. Physical Review E, 84(5), 051121.","category":"page"},{"location":"algorithms/delaymnrm/#Delay-Modified-Next-Reaction-Method-Algorithm","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"","category":"section"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"  No matter whether a reaction is contained in textND, textCD, or textICD, the number of initiations at absolute time t will be given by","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"textnumber of initiations of reaction  k text by time  t = Y_kBig(int_0^t a_k(X(s)Big) mathrmds)","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"where the Y_k are independent, unit rate Poisson processes.","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"  More specifically, if we define T_k(t) =int_0^t a_k(X(s)) mathrmds for each k, then it is relevant for us to consider Y_k(T_k(t)). We will call T_k(t) the \"internal time\" for reaction k.","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"  Because the initiations are still given by the firing times of independent Poisson processes. Therefore, if T_k is the current internal time of Y_k, P_k the first internal time after T_k at which Y_k fires, and the propensity function for the kth reaction channel is given by a_k, then the time until the next initiation of reaction k(assuming no other reactions initiate or complete) is still given by Delta t_k= (P_kT_k)a_k. The only change to the algorithm will be in keeping track and storing the delayed completions. To each delayed reaction channel we therefore assign a vector, s_k, that stores the completion times of that reaction in ascending order. Thus, the time until there is a change in the state of the system, be it an initiation or a completion, will be given by:","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Delta = minDelta t_k s_k(1)  t","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"where t is the current time of the system. These ideas form the heart of our Next Reaction Method [1] for systems with delays.","category":"page"},{"location":"algorithms/delaymnrm/#Algorithm","page":"Delay Modified Next Reaction Method Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Initialize. Set the initial number of molecules of each species and set t = 0. For each k leq M, set P_k = 0 and T_k = 0, and for each delayed reaction channel set s_k = infty.\nCalculate the propensity function, a_k, for each reaction.\nGenerate M independent, uniform(01) random numbers, r_k, and set P_k = ln(1r_k).\nSet Delta t_k = (P_k  T_k)a_k.\nSet Delta = min_kDelta t_k s_k(1)  t.\nSet t = t + Delta.\nIf we chose the completion of the delayed reaction mu:\nUpdate the system based upon the completion of the reaction mu.\nDelete the first row of S_mu.\nElseif reaction mu initiated and muin textND\nUpdate the system according to reaction mu.\nElseif reaction mu initiated and muin textCD\nUpdate s_mu by inserting t + tau_mu into s_mu in the second to last position.\nElseif reaction mu initiated and muin textICD\nUpdate the system based upon the initiation of reaction mu.\nUpdate s_mu by inserting t + tau_mu into s_mu in the second to last position.\nFor each k, set T_k = T_k + a_k Delta.\nIf reaction mu initiated, let r be uniform(01) and set P_mu = P_mu + ln(1r).\nRecalculate the propensity functions, a_k.\nReturn to step 4 or quit.","category":"page"},{"location":"algorithms/delaymnrm/#Reference","page":"Delay Modified Next Reaction Method Algorithm","title":"Reference","text":"","category":"section"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"[1] David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998.","category":"page"},{"location":"algorithms/delaydirect/#Delay-Direct-Method-Algorithm","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"","category":"section"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"  The number of discarded Delta will be approximately equal to the number of delayed reactions that initiate. This follows because, other than the stored completions at the time the code terminates, every delayed completion will cause one computed Delta to be discarded. Thus, Cai [1] developped an algorithm, called the Direct Method for systems with delays, in which no random variables are discarded.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"  The principle of Direct Method is the same as that of the original Gillespie Algorithm and the Rejection Method above: use one random variable to calculate when the next reaction initiates and use another random variable to calculate which reaction occurs at that future time. However, Direct Method updates the state of the system and propensity functions due to stored delayed reactions during the search for the next initiation time. In this way he ensures that no random variables are discarded as in the Rejection Method. ","category":"page"},{"location":"algorithms/delaydirect/#Algorithm","page":"Delay Direct Method Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"  Suppose that at time t there are ongoing delayed reactions set to complete at times t+T_1 t+T_2 ldots t+T_d. Define T_0=0 and T_d+1=infty.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Define Tstruct, whose i-th (i=1dotsd) row stores T_i and the index, mu_i, of the reaction that T_i is associated with.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Initialize. Set the initial number of molecules of each species and set  t=0. Clear Tstruct.\nCalculate the propensity of function a_k, for each reaction k in 1ldots M.\nSet a_0=sum_k=1^Ma_k.\nGenerate  Delta.\nInput the time t and a_0=sum_k=1^Ma_k.\nGenerate an independent uniform (01) random number r_1.\nIf Tstruct is empty \nThis means there is no ongoing delay reactions, set Delta = 1a_0ln(1r_1).\nElse\nSet i=1, a_t = a_0T_1 and  F=1-e^-a_t.\nWhile F  r_1\nUpdate the state vector x_1 due to the finish of the delayed reaction t+T_i.\nCalculate propensity a_k(t+T_i+1) due to the finish of the delayed reaction at t+T_i+1 and calculate a_0(t+T_i+1).\nUpdate a_t=a_t+a_0(t+T_i+1)(T_i+1-T_i).\nUpdate F=1-e^-a_t \ni=i+1\n.\nEndWhile\nCalculate Calculate propensity a_k(t+T_i) due to the finish of the delayed reaction at t+T_i and calculate a_0(t+T_i).\nSet Delta=T_i-(ln(1-r_1)+a_t-a_0(t+T_i)(T_i+1-T_i))a_0(t+T_i).\nEndIf\nIf DeltainT_iT_i+1), delete the columns 1ldotsi of T_i and set T_j=T_j-Delta.\nGenerate an independent uniform (01) random number r_2.\nFind muin1dotsm such that\nsum_k=1^mu-1 a_k  r_2 leq sum_k=1^mua_k\nwhere the a_k and a_0 are generated in step 4.\nIf muin textND , update the number of each molecular species according to the reaction mu\nIf muin textCD, update Tstruct by adding the row tau_mumu so that Tstruct(i1)Tstruct(i+11) still holds for all i.\nIf muin textICD, update the system according to the initiation of mu and update Tstruct by adding the row tau_mumu so that Tstruct(i1)Tstruct(i+11) still holds for all i.\nSet t=t+Delta.\nReturn to Step 2 or quit.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Remark. Notice that in the above pseudo-code, we modified the Step 4. in the orignal algorithm but both are equivalent.","category":"page"},{"location":"algorithms/delaydirect/#Reference","page":"Delay Direct Method Algorithm","title":"Reference","text":"","category":"section"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"[1] Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DelaySSAdocs","category":"page"},{"location":"#DelaySSAToolkit","page":"Home","title":"DelaySSAToolkit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gillespie developed a stochastic simulation algorithm (SSA) to simulate stochastic dynamics of chemically reacting systems [1]. In SSA algorithm, it is assumed that all reactions occur instantaneously. While in many biochemical reactions, such as gene transcription and translation, it can take certain time to finish after the reactions are initiated [2]. Neglecting delays in certain cases may still produce acceptable results, but in some delay-sensitive cases, such as delay-induced oscillators, neglecting delays in simulation will lead to erroneous conclusions. To solve this problem, an exact SSA for chemical reaction systems with delays，Delay SSA [3-5] was proposed, based upon the same fundamental premise of stochastic kinetics used by Gillespie in the development of his SSA.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DelaySSAToolkit.jl is a tool developed on top of DiffEqJump.jl which solves the stochastic simulation with delay and contains the following features:","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Various delay stochastic simulation algorithms are provided;\nStochastic delay type is supported;\nMultiple delay channels and simultaneous delay reactions are supported;\nPriority queue and dependency graph are integrated for high computational performance;\nEcosystem with Catalyst, DiffEqJump, DifferentialEquations and more...","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DelaySSAToolkit can be installed through the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/palmtree2013/DelaySSAToolkit.jl\nusing DelaySSAToolkit","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Daniel T. Gillespie \"Exact stochastic simulation of coupled chemical reactions\", J. Phys. Chem. 1977, 81, 25, 2340–2361. https://doi.org/10.1021/j100540a008","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Qingchao Jiang, Xiaoming Fu, Shifu Yan, Runlai Li, Wenli Du, Zhixing Cao, Feng Qian, Ramon Grima, \"Neural network aided approximation and parameter inference of non-Markovian models of gene expression\". Nature communications, (2021) 12(1), 1-12. https://doi.org/10.1038/s41467-021-22919-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3] Barrio, Manuel, Kevin Burrage, André Leier, and Tianhai Tian. \"Oscillatory regulation of Hes1: discrete stochastic delay modelling and simulation.\" PLoS computational biology 2, no. 9 (2006): e117. https://doi.org/10.1371/journal.pcbi.0020117","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4] Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5] David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998.","category":"page"}]
}
